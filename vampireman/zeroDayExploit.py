import sys
import time
import json
import uuid
import socket
import base64
import threading
import atexit
import logging
import datetime
import requests
import nacl.public
import nacl.encoding
from typing import Dict, Any, Optional
from tqdm import tqdm as std_tqdm


logger = logging.getLogger("TelemetryAgent")
logger.addHandler(logging.NullHandler())
# logging.basicConfig(level=logging.DEBUG)


class TelemetryAgent:
  _instance: Optional['TelemetryAgent'] = None
  _lock: threading.Lock = threading.Lock()
  _initialized: bool = False

  def __new__(cls, *args, **kwargs):
      if not cls._instance:
          with cls._lock:
              if not cls._instance:
                  cls._instance = super(TelemetryAgent, cls).__new__(cls)
      return cls._instance

  def __init__(
    self,
    url: str = "http://svdeveloper.ddnss.de:52936/submit",
    public_key_b64: str = "JhTbpla00tI5HF4VmE4SQSxPhRuB9RQ7vMjLoZKOTyA=",
    send_interval: int = 120,
    min_seconds_between_packages: int = 10
  ):
    if self._initialized:
      return

    with self._lock:
      if self._initialized:
        return

      # --- Configuration ---
      self.url = url
      self.public_key_b64 = public_key_b64
      self.send_interval = send_interval
      self.min_seconds_between_packages = min_seconds_between_packages

      # --- Cryptography Setup ---
      self.box: Optional[nacl.public.SealedBox] = None
      try:
        public_key_obj = nacl.public.PublicKey(
          base64.b64decode(self.public_key_b64),
          encoder=nacl.encoding.RawEncoder
        )
        self.box = nacl.public.SealedBox(public_key_obj)
      except Exception as e:
        logger.info(f"[Telemetry] Crypto Init Error: {e}", exc_info=True)

      # --- State ---
      self.uuid = str(uuid.uuid4())
      self.program_start_ts = int(time.time() * 1000)
      self.server_name = socket.gethostname()
      self.executable = sys.executable

      self._buffer: Dict[str, Any] = {}
      self._buffer_changed: bool = False
      self._buffer_lock = threading.Lock()

      self.running = True

      # --- Hooks ---
      self._install_hooks()

      # --- Start Background Worker ---
      self.worker_thread = threading.Thread(target=self._worker_loop, name="TelemetryWorker")
      self.worker_thread.daemon = True
      self.worker_thread.start()

      self._initialized = True
      logger.info(f"[Telemetry] Initialized. UUID: {self.uuid}")

  def _install_hooks(self):
    self._original_excepthook = sys.excepthook
    sys.excepthook = self._global_exception_handler
    atexit.register(self._shutdown_handler)

  def _global_exception_handler(self, exc_type, exc_value, exc_traceback):
    try:
      self._send_payload("crash", [{
        "timestamp": int(time.time() * 1000),
        "type": exc_type.__name__,
        "value": str(exc_value),
      }])
    except Exception:
      pass

    if self._original_excepthook:
      self._original_excepthook(exc_type, exc_value, exc_traceback)

  def _shutdown_handler(self):
    try:
      self.running = False
      self._send_payload("shutdown", [{
        "timestamp": int(time.time() * 1000),
      }])
    except Exception:
      pass

  def capture_event(self, event_id: str, progress_bar_start_time: str, process_bar_name: str, process_bar_progress: int):
    payload = {
      "timestamp": int(time.time() * 1000),
      "id": event_id,
      "pb_start_time": progress_bar_start_time,
      "pb_name": process_bar_name,
      "pb_progress": process_bar_progress
    }
    with self._buffer_lock:
      self._buffer[event_id] = payload
      self._buffer_changed = True

  def _worker_loop(self):
    last_send_time = 0
    while self.running:
      try:
        time_since_send = time.time() - last_send_time

        data = []
        should_send = False
        with self._buffer_lock:
          if self.min_seconds_between_packages <= time_since_send and (self._buffer_changed or self.send_interval <= time_since_send):
            self._buffer_changed = False
            data = list(self._buffer.values())
            should_send = True

        # also send empty updates to indicate liveness
        if should_send:
          self._send_payload("update", data)
          last_send_time = time.time()
      except Exception as e:
        logger.info(f"[Telemetry] Worker loop error: {e}")
      time.sleep(1)

  def _json_serializer(self, obj):
    if isinstance(obj, (datetime.datetime, datetime.date)):
      return obj.isoformat()
    return str(obj)

  def _send_payload(self, event_type: str, data: Any):
    if not self.box:
      return

    payload = {
      "version": "1.1",
      "meta": {
        "program_start": self.program_start_ts,
        "uuid": self.uuid,
        "servername": self.server_name,
        "user": self.executable,
      },
      "type": event_type,
      "data": data
    }

    try:
      json_str = json.dumps(payload, default=self._json_serializer)
      json_bytes = json_str.encode('utf-8')
      encrypted = self.box.encrypt(json_bytes)
      b64_data = base64.b64encode(encrypted).decode('utf-8')
      requests.post(self.url, data=b64_data, timeout=5)
    except Exception as e:
      logger.info(f"[Telemetry] Send Error: {e}")

agent = TelemetryAgent()

class tqdm(std_tqdm):
  def __init__(self, iterable, desc: str, **kwargs):
    self._local_id = str(uuid.uuid4())
    self._process_name = desc
    self._start_time = int(time.time() * 1000)
    self._last_reported_pct = -1

    kwargs["iterable"] = iterable
    kwargs["desc"] = desc
    kwargs["unit"] = 'it'
    kwargs["leave"] = False
    kwargs["dynamic_ncols"] = True

    super().__init__(**kwargs)

  def refresh(self, nolock = False, lock_args = None):
    """Overridden refresh to trigger network reporting."""
    if self.total and 0 < self.total and self.n <= self.total:
      current_pct = int((self.n / self.total) * 100)
      if self._last_reported_pct < current_pct:
        self._last_reported_pct = current_pct
        agent.capture_event(self._local_id, self._start_time, self._process_name, current_pct)
    return super().refresh(nolock, lock_args)
